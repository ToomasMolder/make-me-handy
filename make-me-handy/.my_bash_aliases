#!/bin/bash
###################################################################
# Script Name   : .my_bash_aliases
# Script version: 1.13
# Script date   : 2022-01-22
# Description   : Get my handy aliases
# Usage         : /bin/cat ~/.my_bash_aliases >> ~/.bash_aliases; source ~/.bash_aliases
# Author        : Toomas MÃ¶lder
# Email         : toomas.molder+makemehandy@gmail.com
###################################################################
#
# Additional notes:
# You may want to put all your additions into a separate file like ~/.bash_aliases
# Usage from ~/.bashrc
# if [ -f ~/.bash_aliases ]; then
#     . ~/.bash_aliases
# fi

alias a='alias'
alias af='alias; declare -F'
alias cc='/usr/bin/clear'
alias ce='/usr/bin/crontab -e'
alias cl='/usr/bin/crontab -l'
alias dfh='/bin/df --human-readable'
alias duh='/usr/bin/du --human-readable'
alias dus='/usr/bin/du --summarize --human-readable'
function dux() { /usr/bin/du --all --human-readable --max-depth=1 "$@" | /usr/bin/sort --human-numeric-sort --reverse; }
alias f='declare -F'
alias h='history'
function hgrep() { history | /bin/grep --extended-regexp --ignore-case --color=auto "${1}"; }
alias lart='/bin/ls --all -l --reverse -t --color=auto'
alias less='/bin/less --RAW-CONTROL-CHARS --LINE-NUMBERS --ignore-case'
alias ll='/bin/ls -l --color=auto'
alias lrt='/bin/ls -l --reverse -t --color=auto'
alias reboot='history -a; /usr/bin/sudo reboot now'
alias rm='/bin/rm --interactive'
alias rmf='/bin/rm'
alias s='/usr/bin/screen'
alias sls='/usr/bin/screen -ls'
function srd() { /usr/bin/screen -r -d "${1}"; }
# Use alias 'sss' instead of 'ss', which is another utility to investigate sockets https://man7.org/linux/man-pages/man8/ss.8.html
function sss() { /usr/bin/screen -S "${1}"; }
# aliases with sudo
# alias sudo='/usr/bin/sudo sh -c "$@"'
alias suduh='/usr/bin/sudo /usr/bin/du --human-readable'
alias sudus='/usr/bin/sudo /usr/bin/du --summarize --human-readable'
function sudux() { /usr/bin/sudo /usr/bin/du --all --human-readable --max-depth=1 "$@" | /usr/bin/sort --human-numeric-sort --reverse; }
alias tf='/usr/bin/tail --follow'
alias think='read -r -p "Press Ctrl-C to cancel or any key to continue ... " -n1 -s'
alias update='/usr/bin/sudo apt-get update; /usr/bin/sudo apt-get dist-upgrade; /usr/bin/sudo apt-get autoremove; read -r -p "Done. Press any key to continue ... " -n1 -s; echo; if [ -f "/var/run/reboot-required" ]; then cat /var/run/reboot-required; fi; if [ -f "/var/run/reboot-required.pkgs" ]; then cat /var/run/reboot-required.pkgs; fi; read -r -p "Reboot now? Press Ctrl-C to cancel or any key to reboot now ... " -n1 -s; history -a; /usr/bin/sudo reboot now'
alias update_y='/usr/bin/sudo apt-get --assume-yes update; /usr/bin/sudo apt-get --assume-yes dist-upgrade; /usr/bin/sudo apt-get --assume-yes autoremove; read -r -p "Done. Press any key to continue ... " -n1 -s; echo; if [ -f "/var/run/reboot-required" ]; then cat /var/run/reboot-required; fi; if [ -f "/var/run/reboot-required.pkgs" ]; then cat /var/run/reboot-required.pkgs; fi; read -r -p "Reboot now? Press Ctrl-C to cancel or any key to reboot now ... " -n1 -s; history -a; /usr/bin/sudo reboot now'

#
# Service status|stop|start|restart
#
# For status it is OK to use all parameters "$@"
function status() { /usr/bin/sudo systemctl --no-pager --full status "$@"; }
# For others, try to be specific
function stop() { /usr/bin/sudo systemctl stop "${1}".service; }
function start() { /usr/bin/sudo systemctl start "${1}".service; }
function restart() { /usr/bin/sudo systemctl restart "${1}".service; }

#
# Journalctl
#
function j() { /usr/bin/sudo journalctl --unit="${1}" | /usr/bin/tail --lines=20; }
function jf() { /usr/bin/sudo journalctl --follow --unit="${1}"; }

#
# Convert epoch date into human readable format
#
function epoch() { /bin/date --date=@"${1}"; }

#
# Find file from current point in directory tree
#
function ff() { /usr/bin/find . -printf "%TY-%Tm-%Td\t%s\t%p\n" | /bin/grep --extended-regexp --ignore-case --color=auto "${1}"; }

#
# Another alias to find file from /, ie in full directory tree
#
function F() {
  if [ -z "${1}" ]; then
    echo "Error: Specify pattern for search";
  else
    sudo /usr/bin/find / -name "*${1}*" -exec /bin/ls --all -l --color=auto --directory {} \;
   fi;
}

#
# Find string within files from current point in directory tree
#
function fsf() {
        # /usr/bin/find . -type f -print0 | xargs -I {} --null grep "${1}" "{}"
        /usr/bin/find . -iname "*" -type f -print0 | /usr/bin/xargs --null /bin/grep --with-filename "${1}"
}

#
# Find string within files from current point up to /
#
function dnif() {
    # Recursively list a file from PWD up the directory tree to root
    [[ -n "${1}" ]] || { echo "dnif [ls-opts] name"; return 1; }
    local THERE="${PWD}" RC=2
    while [[ "${THERE}" != "/" ]]
        do [[ -e "${THERE}"/"${2:-$1}" ]] && { /bin/ls "${2:+$1}" "${THERE}"/"${2:-$1}"; RC=0; }
            THERE=$(/usr/bin/dirname "${THERE}")
        done
    [[ -e "${THERE}"/"${2:-$1}" ]] && { /bin/ls "${2:+$1}" /"${2:-$1}"; RC=0; }
    return "${RC}"
}

#
# Sniff network
#
function net () {
    # myself_IP=$(echo "${SSH_CONNECTION}" | /usr/bin/cut --delimiter=" " --fields=1);
    myself_IP=$(echo "${SSH_CLIENT}" | /usr/bin/cut --delimiter=" " --fields=1);
    myself_name=$(host "${myself_IP}" | /usr/bin/cut --delimiter=" " --fields=5 | /bin/sed --expression="s/\.$//");
    sudo /usr/sbin/tcpdump -i eth0 src "$(/bin/hostname --ip-address)" and dst not "${myself_name}" and dst net not 10.0.0.0/8 and port not 22
}